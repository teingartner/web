<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Based Proximity Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
        }
        svg {
            display: block;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 5px;
            font-size: 13px;
            background: #F2F2F2;
            border: 0px;
            border-radius: 2px;
            pointer-events: none;
            visibility: hidden;
            z-index: 1;
            /* Initially hidden */
        }
    </style>
</head>
<body>
    <svg width="800" height="600"></svg>
    <script>
        // Set up SVG dimensions
        const width = 800;
        const height = 600;

        const regex = /c\((-?\d+\.\d+),\s*(-?\d+\.\d+)\)/;
        var datal = d3.tsv("/data/stops.csv", (d) => {
            // console.log(d)
            let match = d.geometry.match(regex); // Match the regex
            let [_, longitude, latitude] = match; // Extract matched groups
            
            return {
                name: d.name,
                description: d.description,
                subway: d.subway  == "yes"? true : false,
                tram: d.tram == "yes"? true : false, 
                train: d.train  == "yes"? true : false,
                lat: parseFloat(latitude),
                lon: parseFloat(longitude),
            };
        }).then((transport_data) => {
            // const points = [
            // { x: 100, y: 100 },
            // { x: 700, y: 100 },
            // { x: 400, y: 300 },
            // { x: 200, y: 500 },
            // { x: 600, y: 500 }
            // ];
            const svg = d3.select("svg");
            d3.select("body").append("div").attr("class", "tooltip")
            var tooltip = d3.select(".tooltip");

            var hochi = {lat: 48.12350105123478, lon: 11.585023975988923}

            var transport_data = transport_data
            var ubahn = transport_data.filter(function (d) { return d.subway == true })
            

            // Create an offscreen canvas for pixel manipulation
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");

            // Get the image data object
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            var yScale = d3.scaleLinear()
                .domain([48.05, 48.25]) //latitude
                .range([height, 0]);
                
            var xScale = d3.scaleLinear()
                .domain([11.43, 11.75]) //longitude
                .range([0, width]);


            function computeColors() {
                // Define a color scale (greener = closer, redder = farther)
                // Calculate the farthest actual distance
                const maxDistance = d3.max(
                    d3.range(height).flatMap(y => 
                        d3.range(width).map(x => 
                            Math.min(...ubahn.map(p => Math.hypot(xScale(p.lon) - x, yScale(p.lat) - y)))
                        )
                    )
                );

                // Define the color scale with dynamic max distance
                const colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
                    .domain([0, maxDistance]);

                // Iterate over each pixel
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Calculate the distance to each point
                        const distances = ubahn.map(p => Math.hypot(xScale(p.lon) - x, yScale(p.lat) - y));
                        const nearestDistance = Math.min(...distances);

                        // Get the color for this distance
                        const color = d3.color(colorScale(nearestDistance));

                        // Calculate the pixel index
                        const pixelIndex = (y * width + x) * 4;

                        // Set the RGBA values
                        data[pixelIndex] = color.r;     // Red
                        data[pixelIndex + 1] = color.g; // Green
                        data[pixelIndex + 2] = color.b; // Blue
                        data[pixelIndex + 3] = 255;     // Alpha (fully opaque)
                    }
                }

                // Put the image data back into the canvas
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL();
            }

            // Load precomputed image if available
            function loadImage(savedImage) {
                const image = new Image();
                image.onload = function () {
                    d3.select("svg")
                        .append("image")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", width)
                        .attr("height", height)
                        .attr("href", image.src)
                        .lower();
                };
                image.src = savedImage;
            }

            // Check for saved image in localStorage
            const savedImage = localStorage.getItem("proximityImage");

            // Convert the canvas to an image and append it to the SVG
            if (savedImage) {
                // Load saved image if it exists
                loadImage(savedImage);
            } else {
                // Recompute and save image
                const newImage = computeColors();
                localStorage.setItem("proximityImage", newImage);

                // Render the newly computed image
                loadImage(newImage);
            }



            

            // Draw the points on top of the image
            svg.selectAll("circle.ubahnen")
                .data(ubahn)
                .join("circle")
                .attr("class", "ubahnen")
                .attr("cx", d => xScale(d.lon))
                .attr("cy", d => yScale(d.lat))
                .attr("r", 5)
                .attr("fill", "black")
                .on("mouseover", function (event, d) {
                    tooltip.style("visibility", "visible").text(d.name);
                    d3.select(this).attr("fill", "grey")
                })
                .on("mousemove", function (event, d) {
                    tooltip.style("top", (event.pageY - 10) + "px")
                    .style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function (event, d) {
                    d3.select(this).attr("fill", "black");
                    tooltip.style("visibility", "hidden");
                });

                // Draw the points on top of the image
                svg.selectAll("circle.hochi")
                    .data([hochi])
                    .join("circle")
                    .attr("class", "hochi")
                    .attr("cx", d => xScale(d.lon))
                    .attr("cy", d => yScale(d.lat))
                    .attr("r", 5)
                    .attr("fill", "pink");

                d3.selectAll("circle").raise()
        

        });
    </script>
</body>
</html>
