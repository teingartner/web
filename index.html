<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Based Proximity Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src=" https://cdn.jsdelivr.net/npm/proj4@2.15.0/dist/proj4.min.js "></script>
    <script src="stadtteile.js"></script>
    
    <style>
        body {
            margin: 0;
        }
        svg {
            display: block;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 5px;
            font-size: 13px;
            background: #F2F2F2;
            border: 0px;
            border-radius: 2px;
            pointer-events: none;
            visibility: hidden;
            z-index: 1;
            /* Initially hidden */
        }
    </style>
</head>
<body>
    <svg width="650" height="600"></svg>
    <script>
        // Set up SVG dimensions
        const width = 650;
        const height = 600;

        

        const svg = d3.select("svg");
        d3.select("body").append("div").attr("class", "tooltip")
        var tooltip = d3.select(".tooltip");

        
        
        var datal = d3.tsv("/data/stops.csv", (d) => {
            // console.log(d)
            const regex = /c\((-?\d+\.\d+),\s*(-?\d+\.\d+)\)/;
            let match = d.geometry.match(regex); // Match the regex
            let [_, longitude, latitude] = match; // Extract matched groups
            
            return {
                name: d.name,
                description: d.description,
                subway: d.subway  == "yes"? true : false,
                tram: d.tram == "yes"? true : false, 
                train: d.train  == "yes"? true : false,
                lat: parseFloat(latitude),
                lon: parseFloat(longitude),
            };
        }).then((transport_data) => {
            var hochi = {lon: 11.585023975988923, lat: 48.12350105123478, }

            var transport_data = transport_data
            var ubahn = transport_data.filter(function (d) {
                return (d.subway == true) || (d.tram == true) || (d.train == true)
            })
             
            var center = [11.57, 48.15]
            addStadtteile(center).then(([lonBbx, latBbx]) => {
                console.log("Bounding box:", latBbx);
           
            var yScale = d3.scaleLinear()
                .domain(latBbx) //latitude
                .range([height, 0]);
                
            var xScale = d3.scaleLinear()
                .domain(lonBbx) //longitude
                .range([0, width]);
            
            // localStorage.clear()    
            addBackground()
            addPoints()
            
            
            function addBackground() {
            
            // Create an offscreen canvas for pixel manipulation
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");

            // Get the image data object
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            // Check for saved image in localStorage
            const savedImage = localStorage.getItem("proximityImage");

            // Convert the canvas to an image and append it to the SVG
            if (savedImage) {
                // Load saved image if it exists
                loadImage(savedImage);
            } else {
                // Recompute and save image
                const newImage = computeColors();
                localStorage.setItem("proximityImage", newImage);

                // Render the newly computed image
                loadImage(newImage);
            }

        
        

        function computeColors() {
            // Define a color scale (greener = closer, redder = farther)
            // Calculate the farthest actual distance
            const maxDistance = d3.max(
                d3.range(height).flatMap(y => 
                    d3.range(width).map(x => 
                        Math.min(...ubahn.map(p => Math.hypot(xScale(p.lon) - x, yScale(p.lat) - y)))
                    )
                )
            );

            // Define the color scale with dynamic max distance
            const colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
                .domain([0, maxDistance]);

            // Iterate over each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Calculate the distance to each point
                    const distances = ubahn.map(p => Math.hypot(xScale(p.lon) - x, yScale(p.lat) - y));
                    const nearestDistance = Math.min(...distances);

                    // Get the color for this distance
                    const color = d3.color(colorScale(nearestDistance));

                    // Calculate the pixel index
                    const pixelIndex = (y * width + x) * 4;

                    // Set the RGBA values
                    data[pixelIndex] = color.r;     // Red
                    data[pixelIndex + 1] = color.g; // Green
                    data[pixelIndex + 2] = color.b; // Blue
                    data[pixelIndex + 3] = 255;     // Alpha (fully opaque)
                }
            }

            // Put the image data back into the canvas
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL();
        }

        // Load precomputed image if available
        function loadImage(savedImage) {
            const image = new Image();
            image.onload = function () {
                d3.select("svg")
                    .append("image")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width)
                    .attr("height", height)
                    .attr("href", image.src)
                    .style("opacity", 0.8)
                    .lower();
            };
            image.src = savedImage;
        }
    }

            
        function addPoints() {
            // Draw the points on top of the image
            svg.append("g").attr("class", "ubahn_points").selectAll("circle.ubahnen")
                .data(ubahn)
                .join("circle")
                .attr("class", "ubahnen")
                .attr("cx", d => xScale(d.lon))
                .attr("cy", d => yScale(d.lat))
                .attr("r", 4)
                .attr("fill", "black")
                .on("mouseover", function (event, d) {
                    tooltip.style("visibility", "visible").text(d.name);
                    d3.select(this).attr("fill", "grey")
                })
                .on("mousemove", function (event, d) {
                    tooltip.style("top", (event.pageY - 10) + "px")
                    .style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function (event, d) {
                    d3.select(this).attr("fill", "black");
                    tooltip.style("visibility", "hidden");
                });

                // Draw the points on top of the image
                svg.selectAll("circle.hochi")
                    .data([hochi])
                    .join("circle")
                    .attr("class", "hochi")
                    .attr("cx", d => xScale(d.lon))
                    .attr("cy", d => yScale(d.lat))
                    .attr("r", 5)
                    .attr("fill", "pink");

                d3.selectAll("circle").raise()

                // Load GeoJSON and draw boroughs
                // Define UTM Zone 32N (ETRS89) and WGS84 projections
                // proj4.defs("EPSG:25832", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs");
                
        }
        
    });
        });
    </script>
</body>
</html>
